Collectors - Utility class in JDK, which is a collection of lot of utility functions which makes our lives easier

Java and Functional Programming:
 - We can not only do imperative & object oriented programming in java, but we can also do functional programming in java
 - Polymorphism is the core or essence of OOP.
 - Functional Programming
 		- Functional composition (syntax) + lazy evaluation (semantics)
 		- One of the benefits of lazy evaluation is that it postpones creation of objects which results in more efficiency
 		- Lazy evaluations require purity of functions.
 			- Pure function returns the same result any number of times we call it with the same input. (Idempotency)
 			- Pure functions don't have side effects
 			- 1. Pure functions do not change anything (This rule is necessary but not sufficient)
 			- 2. Pure functions do not depend on anything that may possibly change (immutability)
 			- It is our responsibility to write pure functions because compiler will not tell us

Stream
 - Not only streams gives us internal iterators but also gives us the capability of lazy evaluation
 - Before java 8 was even released we could actually call filter operation directly on the collection.
 - Later it was removed, because the method forEach uses eager evaluation but filter gives us lazy evaluation.
 - The syntax .stream() conveys a semantical transformation from eager evaluation to lazy evaluation.
 - Filter allows us the ability to pick certain values and skip which are not required from collection.
 - Map is a transformation function which takes a each value from collection and transforms it into another value.
 - Reduce takes the collection & reduces to a single value.
   Reduce converts a Stream to something concrete. It doesn't always have to give single value.
   You can go from collection of persons to collection of names or even collection of ages.
   Java has reduce in two forms:
   		- reduce & collect
   		- sum
   		
 - Collector work with 3 different types i.e. Collector<T, A, R>
 			--> T is the object your are dealing with, A is the accumulator of operations and R becomes the value after combining accumulated values
 			--> By definition collectors engage into mutability but they keep mutability local

 - Understand map v/s mapping (i.e. in the middle of reduce) & filter v/s filtering (i.e. in the middle of reduce) filtering introduced in java 10/11
 - groupingBy & mapping takes (Function, Collector)
 - counting itself is a collector and therefore we need (Collector, Function) which will transform the Long to Integer
 - collectingAndThen take (Collector, Function)
 - teeing (Collector, Collector, operation) introduced in java 11
 
 Exception Handling
 
  - Exception handling is an imperative style of programming concept.
  - In functional programming we deal with stream of data - data flow
  - Exception handling makes zero sense when dealing with functional programming. It does not mean error is not important but exceptions don't make any sense because they blow up your stack.
  - In functional programming you deal with the exceptions downstream.
  - Example in Reactive library, they gave use 3 channels : data channel, error channel & complete channel
  			- Data channel carries the data
  			- When something goes wrong the error channel carries the error
  			- That means data & channel are both different types of data
  